{"version":3,"sources":["../src/index.ts","../node_modules/svelte/src/internal/shared/utils.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/store/utils.js","../node_modules/svelte/src/store/shared/index.js"],"sourcesContent":["import { writable, get } from 'svelte/store';\n\n/**\n * This type represents the state of an item in the cache store. The state can be one of the following:\n * - 'loading': The item is being fetched from the backend.\n * - 'loaded': The item has been successfully fetched from the backend.\n * - 'updating': The item is being updated on the backend.\n * - 'deleting': The item is being deleted from the backend.\n * - 'error': An error occurred while fetching, updating, or deleting the item.\n */\nexport type CacheState = 'loading' | 'loaded' | 'updating' | 'deleting' | 'error';\n\n/**\n * This interface represents the base structure of an item in the cache store. Any item that is stored in the cache\n * store must implement this interface. It enforces that each item has a unique ID from the backend, and adds a state\n * property to track the state of the item (loading, loaded, updating, deleting, or error). The error property is a\n * boolean that indicates whether an error occurred while fetching, updating, or deleting the item. The errorMessage\n * property contains the error message if an error occurred, or null if no error occurred.\n *\n * @param id - The unique ID of the item.\n * @param state - The state of the item (loading, loaded, updating, deleting, or error).\n * @param error - A boolean indicating whether an error occurred while fetching, updating, or deleting the item.\n * @param errorMessage - The error message if an error occurred, or null if no error occurred.\n */\nexport interface CacheItem {\n    id: string;\n    state: CacheState;\n    error: boolean;\n    errorMessage: string | null;\n}\n\ninterface SortColumn {\n    sortColumn: string;\n    sortOrder?: 'ascending' | 'asc' | 'descending' | 'desc';\n}\n\ninterface CacheRegistry<T extends CacheItem> {\n    cache: ReturnType<typeof writable<{ [id: string]: T }>>;\n    singularName: string;\n    pluralName: string;\n    apiPrefix: string;\n    hasFetchedAll: boolean;\n}\n\n// Type guard to check if the error is an instance of Error\nfunction isErrorWithMessage(error: unknown): error is { message: string } {\n    return (\n        typeof error === 'object' &&\n        error !== null &&\n        'message' in error &&\n        typeof (error as any).message === 'string'\n    );\n}\n\nexport let cacheStore = createCacheStore();\n\n/**\n * Create a cache store for fetching, creating, updating, and deleting items of a specific type adhering to the\n * simple-json-api specification\n */\nfunction createCacheStore() {\n    const registry = new Map<string, CacheRegistry<any>>();\n\n    /**\n     * Register a type in the cache store. The type must be registered before any operations can be performed on it.\n     * @param singularName\n     * @param pluralName\n     * @param apiPrefix\n     */\n    function registerType<T extends CacheItem>(singularName: string, pluralName: string, apiPrefix: string) {\n        const cache = writable<{ [id: string]: T }>({});\n        registry.set(singularName, {\n            cache,\n            singularName,\n            pluralName,\n            apiPrefix,\n            hasFetchedAll: false,\n        } as CacheRegistry<T>);\n    }\n\n    /**\n     * Get the cached items for a specific type.\n     * @param singularName\n     */\n    function getCache<T extends CacheItem>(singularName: string) {\n        const registryEntry = registry.get(singularName) as CacheRegistry<T>;\n        if (!registryEntry) {\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n        }\n        return registryEntry.cache;\n    }\n\n    /**\n     * Sort the data based on the provided list of sort columns, starting with the first column in the list.\n     * @param data\n     * @param sortColumns\n     */\n    function sortData<T>(data: T[], sortColumns?: SortColumn[]): T[] {\n        if (!sortColumns || sortColumns.length === 0) return data;\n\n        return data.sort((a, b) => {\n            for (let sort of sortColumns) {\n                const { sortColumn, sortOrder } = sort;\n                const order = sortOrder?.toLowerCase();\n\n                const aValue = (a as any)[sortColumn];\n                const bValue = (b as any)[sortColumn];\n\n                if (aValue < bValue) return order === 'desc' || order === 'descending' ? 1 : -1;\n                if (aValue > bValue) return order === 'desc' || order === 'descending' ? -1 : 1;\n            }\n            return 0;\n        });\n    }\n\n    /**\n     * Fetch an item by its ID.\n     * @param singularName\n     * @param id\n     */\n    async function fetchById<T extends CacheItem>(singularName: string, id: string): Promise<T> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache, pluralName, apiPrefix } = typeRegistry;\n\n        let cacheValue = (get(cache) as { [key: string]: T })[id];\n\n        // If the item is not in the cache or is in an error state, fetch it from the backend\n        if (!cacheValue || (cacheValue != null && cacheValue.state === 'error')) {\n            cacheValue = {\n                id,\n                state: 'loading',\n                error: false,\n                errorMessage: null,\n            } as T;\n            cache.update((current: any) => ({ ...current, [id]: cacheValue }));\n\n            try {\n                const response = await fetch(`${apiPrefix}/${pluralName}/${id}`);\n                if (!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`);\n\n                const json = await response.json();\n                handleSideLoading(singularName, pluralName, json);\n\n                const data = json[singularName] as T;\n                data.state = 'loaded';\n                data.error = false;\n                data.errorMessage = null;\n\n                cache.update((current: any) => ({ ...current, [id]: data }));\n                cacheValue = data;\n            } catch (error) {\n                let errorMessage = 'An unknown error occurred';\n                if (isErrorWithMessage(error)) {\n                    errorMessage = error.message;\n                }\n                cache.update((current: any) => ({\n                    ...current,\n                    [id]: { ...cacheValue, state: 'error', error: true, errorMessage },\n                }));\n                console.error(`Failed to fetch ${id}:`, errorMessage);\n            }\n        }\n\n        return cacheValue;\n    }\n\n    /**\n     * Fetch all items of a specific type.\n     * @param singularName\n     * @param sortColumns\n     */\n    async function fetchAll<T extends CacheItem>(singularName: string, sortColumns?: SortColumn[]): Promise<T[]> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache, pluralName, apiPrefix, hasFetchedAll } = typeRegistry;\n        let cacheValue = get(cache) as { [key: string]: T };\n\n        //Return immediately if all data has been fetched for this type\n        if (hasFetchedAll) {\n            return Object.values(cacheValue);\n        }\n\n        try {\n            const response = await fetch(`${apiPrefix}/${pluralName}`);\n            if (!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`);\n\n            const json = await response.json();\n            handleSideLoading(singularName, pluralName, json);\n\n            let items = json[pluralName] as T[];\n            items = sortData(items, sortColumns);\n\n            items.forEach((item) => {\n                item.state = 'loaded';\n                item.error = false;\n                item.errorMessage = null;\n            });\n\n            const newCacheValue = Object.fromEntries(items.map((item: T) => [item.id, item]));\n            cache.set(newCacheValue);\n\n            // Mark this data as having been fetched\n            typeRegistry.hasFetchedAll = true;\n            cacheValue = newCacheValue;\n        } catch (error) {\n            let errorMessage = 'An unknown error occurred';\n            if (isErrorWithMessage(error)) {\n                errorMessage = error.message;\n            }\n\n            cache.update((current: any) => {\n                const updated = { ...current };\n                Object.keys(updated).forEach((id) => {\n                    updated[id].state = 'error';\n                    updated[id].error = true;\n                    updated[id].errorMessage = errorMessage;\n                });\n                return updated;\n            });\n            console.error('Failed to fetch all:', errorMessage);\n        }\n\n        return Object.values(cacheValue);\n    }\n\n    /**\n     * Handle side-loading of data.\n     * @param mainSingularKey\n     * @param mainPluralKey\n     * @param data\n     */\n    function handleSideLoading(mainSingularKey: string, mainPluralKey: string, data: any) {\n        for (let key of Object.keys(data)) {\n            // iterate over registered types to find matching pluralName\n            let sideloadKey = null;\n            for (let [singularName, registryValue] of registry) {\n                if (registryValue.pluralName === key) {\n                    sideloadKey = singularName;\n                    break;\n                }\n            }\n\n            if (key !== mainSingularKey && key !== mainPluralKey && sideloadKey !== null) {\n                const registryEntry = registry.get(sideloadKey)!;\n                const cache = registryEntry.cache;\n                let sideLoadedData = data[key];\n\n                if (Array.isArray(sideLoadedData)) {\n                    sideLoadedData.forEach((item: CacheItem) => {\n                        item.state = 'loaded';\n                        item.error = false;\n                        item.errorMessage = null;\n                    });\n\n                    let sideLoadedCache = Object.fromEntries(\n                        sideLoadedData.map((item: CacheItem) => [item.id, item])\n                    );\n\n                    cache.update((current: any) => ({ ...current, ...sideLoadedCache }));\n                } else {\n                    console.warn(\n                        `Expected an array for side-loaded data '${key}', but received`,\n                        sideLoadedData\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Reload an item by its ID. This function first removes the item from the cache and then fetches it from the\n     * backend via fetchById.\n     * @param singularName\n     * @param id\n     */\n    async function reloadById<T extends CacheItem>(singularName: string, id: string): Promise<T> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache } = typeRegistry;\n        cache.update((current: { [x: string]: any }) => {\n            const { [id]: _, ...rest } = current;\n            return rest;\n        });\n        return await fetchById<T>(singularName, id);\n    }\n\n    /**\n     * Reload all items of a specific type. This function first invalidates the cache for the type and then fetches all\n     * items from the backend via fetchAll.\n     * @param singularName\n     * @param sortColumns\n     */\n    async function reloadAll<T extends CacheItem>(\n        singularName: string,\n        sortColumns?: SortColumn[]\n    ): Promise<T[]> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache } = typeRegistry;\n        cache.set({}); // Invalidate all cache\n\n        // Reset the hasFetchedAll flag before re-fetching\n        typeRegistry.hasFetchedAll = false;\n\n        return await fetchAll<T>(singularName, sortColumns);\n    }\n\n    /**\n     * Create a new item. The item must be of a type that has been registered in the cache store, and the type\n     * needs to extend the CacheItem interface.\n     * @param singularName\n     * @param item\n     */\n    async function create<T extends CacheItem>(singularName: string, item: T): Promise<void> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache, pluralName, apiPrefix } = typeRegistry;\n\n        try {\n            const response = await fetch(`${apiPrefix}/${pluralName}`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ [singularName]: item }),\n            });\n\n            if (!response.ok) throw new Error(`Failed to create: ${response.statusText}`);\n\n            const json = await response.json();\n            handleSideLoading(singularName, pluralName, json);\n\n            const newItem = json[singularName] as T;\n            newItem.state = 'loaded';\n            newItem.error = false;\n            newItem.errorMessage = null;\n\n            cache.update((current: any) => ({\n                ...current,\n                [newItem.id]: newItem,\n            }));\n        } catch (error) {\n            let errorMessage = 'An unknown error occurred';\n            if (isErrorWithMessage(error)) {\n                errorMessage = error.message;\n            }\n            console.error('Failed to create item:', errorMessage);\n        }\n    }\n\n    /**\n     * Update an item by its ID.\n     * @param singularName\n     * @param id\n     * @param item\n     */\n    async function update<T extends CacheItem>(singularName: string, id: string, item: Partial<T>): Promise<void> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache, pluralName, apiPrefix } = typeRegistry;\n\n        cache.update((current: { [x: string]: T }) => ({\n            ...current,\n            [id]: { ...current[id], state: 'updating', error: false, errorMessage: null },\n        }));\n\n        try {\n            const response = await fetch(`${apiPrefix}/${pluralName}/${id}`, {\n                method: 'PATCH',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ [singularName]: item }),\n            });\n\n            if (!response.ok) throw new Error(`Failed to update: ${response.statusText}`);\n\n            const json = await response.json();\n            handleSideLoading(singularName, pluralName, json);\n\n            const updatedItem = json[singularName] as T;\n            updatedItem.state = 'loaded';\n            updatedItem.error = false;\n            updatedItem.errorMessage = null;\n\n            cache.update((current: any) => ({\n                ...current,\n                [updatedItem.id]: updatedItem,\n            }));\n        } catch (error) {\n            let errorMessage = 'An unknown error occurred';\n            if (isErrorWithMessage(error)) {\n                errorMessage = error.message;\n            }\n            cache.update((current: { [x: string]: T }) => ({\n                ...current,\n                [id]: { ...current[id], state: 'error', error: true, errorMessage },\n            }));\n            console.error(`Failed to update ${id}:`, errorMessage);\n        }\n    }\n\n    /**\n     * Remove an item by its ID.\n     * @param singularName\n     * @param id\n     */\n    async function remove<T extends CacheItem>(singularName: string, id: string): Promise<void> {\n        const typeRegistry = registry.get(singularName) as CacheRegistry<T>;\n        if (!typeRegistry)\n            throw new Error(`Type ${singularName} is not registered in the cache store.`);\n\n        const { cache, pluralName, apiPrefix } = typeRegistry;\n\n        cache.update((current: { [x: string]: T }) => ({\n            ...current,\n            [id]: { ...current[id], state: 'deleting', error: false, errorMessage: null },\n        }));\n\n        try {\n            const response = await fetch(`${apiPrefix}/${pluralName}/${id}`, {\n                method: 'DELETE',\n            });\n\n            if (!response.ok) throw new Error(`Failed to delete: ${response.statusText}`);\n\n            cache.update((current: { [x: string]: T }) => {\n                const { [id]: _, ...rest } = current;\n                return rest;\n            });\n        } catch (error) {\n            let errorMessage = 'An unknown error occurred';\n            if (isErrorWithMessage(error)) {\n                errorMessage = error.message;\n            }\n            cache.update((current: { [x: string]: T }) => ({\n                ...current,\n                [id]: { ...current[id], state: 'error', error: true, errorMessage },\n            }));\n            console.error(`Failed to delete ${id}:`, errorMessage);\n        }\n    }\n\n    return {\n        registerType,\n        fetchById,\n        fetchAll,\n        reloadById,\n        reloadAll,\n        create,\n        update,\n        remove,\n        getCache,\n    };\n}\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/** @import { Readable } from './public' */\nimport { noop } from '../internal/shared/utils.js';\n\n/**\n * @template T\n * @param {Readable<T> | null | undefined} store\n * @param {(value: T) => void} run\n * @param {(value: T) => void} [invalidate]\n * @returns {() => void}\n */\nexport function subscribe_to_store(store, run, invalidate) {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined);\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined);\n\n\t\treturn noop;\n\t}\n\n\t// Svelte store takes a private second argument\n\tconst unsub = store.subscribe(\n\t\trun,\n\t\t// @ts-expect-error\n\t\tinvalidate\n\t);\n\n\t// Also support RxJS\n\t// @ts-expect-error TODO fix this in the types?\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n","/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */\n/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */\nimport { noop, run_all } from '../../internal/shared/utils.js';\nimport { safe_not_equal } from '../../internal/client/reactivity/equality.js';\nimport { subscribe_to_store } from '../utils.js';\n\n/**\n * @type {Array<SubscribeInvalidateTuple<any> | any>}\n */\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {StartStopNotifier<T>} [start]\n * @returns {Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {Unsubscriber | null} */\n\tlet stop = null;\n\n\t/** @type {Set<SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\n\t/**\n\t * @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(/** @type {T} */ (value)));\n\t}\n\n\t/**\n\t * @param {Subscriber<T>} run\n\t * @param {() => void} [invalidate]\n\t * @returns {Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(/** @type {T} */ (value));\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>, set: (value: T) => void, update: (fn: Updater<T>) => void) => Unsubscriber | void} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {Stores} S\n * @template T\n * @overload\n * @param {S} stores\n * @param {(values: StoresValues<S>) => T} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\n/**\n * @template {Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\t/** @type {T[]} */\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = typeof result === 'function' ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe_to_store(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {Readable<T>} store  - store to make readonly\n * @returns {Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\t// @ts-expect-error TODO i suspect the bind is unnecessary\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {Readable<T>} store\n * @returns {T}\n */\nexport function get(store) {\n\tlet value;\n\tsubscribe_to_store(store, (_) => (value = _))();\n\t// @ts-expect-error\n\treturn value;\n}\n"],"mappings":"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","names":[]}